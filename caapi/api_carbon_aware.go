/*
 * CarbonAware.WebApi, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 1.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package caapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"time"
	"reflect"
)

// Linger please
var (
	_ _context.Context
)

// CarbonAwareApiService CarbonAwareApi service
type CarbonAwareApiService service

type ApiBatchForecastDataAsyncRequest struct {
	ctx _context.Context
	ApiService *CarbonAwareApiService
	emissionsForecastBatchDTO *[]EmissionsForecastBatchDTO
}

func (r ApiBatchForecastDataAsyncRequest) EmissionsForecastBatchDTO(emissionsForecastBatchDTO []EmissionsForecastBatchDTO) ApiBatchForecastDataAsyncRequest {
	r.emissionsForecastBatchDTO = &emissionsForecastBatchDTO
	return r
}

func (r ApiBatchForecastDataAsyncRequest) Execute() ([]EmissionsForecastDTO, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.BatchForecastDataAsyncExecute(r)
}

/*
 * BatchForecastDataAsync Given an array of historical forecasts, retrieves the data that contains  forecasts metadata, the optimal forecast and a range of forecasts filtered by the attributes [start...end] if provided.
 * This endpoint takes a batch of requests for historical forecast data, fetches them, and calculates the optimal 
marginal carbon intensity windows for each using the same parameters available to the '/emissions/forecasts/current'
endpoint.
            
This endpoint is useful for back-testing what one might have done in the past, if they had access to the 
current forecast at the time.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiBatchForecastDataAsyncRequest
 */
func (a *CarbonAwareApiService) BatchForecastDataAsync(ctx _context.Context) ApiBatchForecastDataAsyncRequest {
	return ApiBatchForecastDataAsyncRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []EmissionsForecastDTO
 */
func (a *CarbonAwareApiService) BatchForecastDataAsyncExecute(r ApiBatchForecastDataAsyncRequest) ([]EmissionsForecastDTO, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  []EmissionsForecastDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CarbonAwareApiService.BatchForecastDataAsync")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/emissions/forecasts/batch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/_*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.emissionsForecastBatchDTO
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ValidationProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiGetAverageCarbonIntensityRequest struct {
	ctx _context.Context
	ApiService *CarbonAwareApiService
	location *string
	startTime *time.Time
	endTime *time.Time
}

func (r ApiGetAverageCarbonIntensityRequest) Location(location string) ApiGetAverageCarbonIntensityRequest {
	r.location = &location
	return r
}
func (r ApiGetAverageCarbonIntensityRequest) StartTime(startTime time.Time) ApiGetAverageCarbonIntensityRequest {
	r.startTime = &startTime
	return r
}
func (r ApiGetAverageCarbonIntensityRequest) EndTime(endTime time.Time) ApiGetAverageCarbonIntensityRequest {
	r.endTime = &endTime
	return r
}

func (r ApiGetAverageCarbonIntensityRequest) Execute() (CarbonIntensityDTO, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.GetAverageCarbonIntensityExecute(r)
}

/*
 * GetAverageCarbonIntensity Retrieves the measured carbon intensity data between the time boundaries and calculates the average carbon intensity during that period.
 * This endpoint is useful for reporting the measured carbon intensity for a specific time period in a specific location.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetAverageCarbonIntensityRequest
 */
func (a *CarbonAwareApiService) GetAverageCarbonIntensity(ctx _context.Context) ApiGetAverageCarbonIntensityRequest {
	return ApiGetAverageCarbonIntensityRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return CarbonIntensityDTO
 */
func (a *CarbonAwareApiService) GetAverageCarbonIntensityExecute(r ApiGetAverageCarbonIntensityRequest) (CarbonIntensityDTO, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  CarbonIntensityDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CarbonAwareApiService.GetAverageCarbonIntensity")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/emissions/average-carbon-intensity"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.location == nil {
		executionError.error = "location is required and must be specified"
		return localVarReturnValue, nil, executionError
	}
	if r.startTime == nil {
		executionError.error = "startTime is required and must be specified"
		return localVarReturnValue, nil, executionError
	}
	if r.endTime == nil {
		executionError.error = "endTime is required and must be specified"
		return localVarReturnValue, nil, executionError
	}

	localVarQueryParams.Add("location", parameterToString(*r.location, ""))
	localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ValidationProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiGetAverageCarbonIntensityBatchRequest struct {
	ctx _context.Context
	ApiService *CarbonAwareApiService
	carbonIntensityBatchDTO *[]CarbonIntensityBatchDTO
}

func (r ApiGetAverageCarbonIntensityBatchRequest) CarbonIntensityBatchDTO(carbonIntensityBatchDTO []CarbonIntensityBatchDTO) ApiGetAverageCarbonIntensityBatchRequest {
	r.carbonIntensityBatchDTO = &carbonIntensityBatchDTO
	return r
}

func (r ApiGetAverageCarbonIntensityBatchRequest) Execute() ([]CarbonIntensityDTO, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.GetAverageCarbonIntensityBatchExecute(r)
}

/*
 * GetAverageCarbonIntensityBatch Given an array of request objects, each with their own location and time boundaries, calculate the average carbon intensity for that location and time period   and return an array of carbon intensity objects.
 * The application only supports batching across a single location with different time boundaries. If multiple locations are provided, an error is returned.
For each item in the request array, the application returns a corresponding object containing the location, time boundaries, and average marginal carbon intensity.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetAverageCarbonIntensityBatchRequest
 */
func (a *CarbonAwareApiService) GetAverageCarbonIntensityBatch(ctx _context.Context) ApiGetAverageCarbonIntensityBatchRequest {
	return ApiGetAverageCarbonIntensityBatchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []CarbonIntensityDTO
 */
func (a *CarbonAwareApiService) GetAverageCarbonIntensityBatchExecute(r ApiGetAverageCarbonIntensityBatchRequest) ([]CarbonIntensityDTO, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  []CarbonIntensityDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CarbonAwareApiService.GetAverageCarbonIntensityBatch")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/emissions/average-carbon-intensity/batch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/_*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.carbonIntensityBatchDTO
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ValidationProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiGetBestEmissionsDataForLocationsByTimeRequest struct {
	ctx _context.Context
	ApiService *CarbonAwareApiService
	location *[]string
	time *time.Time
	toTime *time.Time
	durationMinutes *int32
}

func (r ApiGetBestEmissionsDataForLocationsByTimeRequest) Location(location []string) ApiGetBestEmissionsDataForLocationsByTimeRequest {
	r.location = &location
	return r
}
func (r ApiGetBestEmissionsDataForLocationsByTimeRequest) Time(time time.Time) ApiGetBestEmissionsDataForLocationsByTimeRequest {
	r.time = &time
	return r
}
func (r ApiGetBestEmissionsDataForLocationsByTimeRequest) ToTime(toTime time.Time) ApiGetBestEmissionsDataForLocationsByTimeRequest {
	r.toTime = &toTime
	return r
}
func (r ApiGetBestEmissionsDataForLocationsByTimeRequest) DurationMinutes(durationMinutes int32) ApiGetBestEmissionsDataForLocationsByTimeRequest {
	r.durationMinutes = &durationMinutes
	return r
}

func (r ApiGetBestEmissionsDataForLocationsByTimeRequest) Execute() ([]EmissionsData, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.GetBestEmissionsDataForLocationsByTimeExecute(r)
}

/*
 * GetBestEmissionsDataForLocationsByTime Calculate the best emission data by list of locations for a specified time period.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetBestEmissionsDataForLocationsByTimeRequest
 */
func (a *CarbonAwareApiService) GetBestEmissionsDataForLocationsByTime(ctx _context.Context) ApiGetBestEmissionsDataForLocationsByTimeRequest {
	return ApiGetBestEmissionsDataForLocationsByTimeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []EmissionsData
 */
func (a *CarbonAwareApiService) GetBestEmissionsDataForLocationsByTimeExecute(r ApiGetBestEmissionsDataForLocationsByTimeRequest) ([]EmissionsData, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  []EmissionsData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CarbonAwareApiService.GetBestEmissionsDataForLocationsByTime")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/emissions/bylocations/best"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.location == nil {
		executionError.error = "location is required and must be specified"
		return localVarReturnValue, nil, executionError
	}

	{
		t := *r.location
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("location", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("location", parameterToString(t, "multi"))
		}
	}
	if r.time != nil {
		localVarQueryParams.Add("time", parameterToString(*r.time, ""))
	}
	if r.toTime != nil {
		localVarQueryParams.Add("toTime", parameterToString(*r.toTime, ""))
	}
	if r.durationMinutes != nil {
		localVarQueryParams.Add("durationMinutes", parameterToString(*r.durationMinutes, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiGetCurrentForecastDataRequest struct {
	ctx _context.Context
	ApiService *CarbonAwareApiService
	location *[]string
	dataStartAt *time.Time
	dataEndAt *time.Time
	windowSize *int32
}

func (r ApiGetCurrentForecastDataRequest) Location(location []string) ApiGetCurrentForecastDataRequest {
	r.location = &location
	return r
}
func (r ApiGetCurrentForecastDataRequest) DataStartAt(dataStartAt time.Time) ApiGetCurrentForecastDataRequest {
	r.dataStartAt = &dataStartAt
	return r
}
func (r ApiGetCurrentForecastDataRequest) DataEndAt(dataEndAt time.Time) ApiGetCurrentForecastDataRequest {
	r.dataEndAt = &dataEndAt
	return r
}
func (r ApiGetCurrentForecastDataRequest) WindowSize(windowSize int32) ApiGetCurrentForecastDataRequest {
	r.windowSize = &windowSize
	return r
}

func (r ApiGetCurrentForecastDataRequest) Execute() ([]EmissionsForecastDTO, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.GetCurrentForecastDataExecute(r)
}

/*
 * GetCurrentForecastData Retrieves the most recent forecasted data and calculates the optimal marginal carbon intensity window.
 * This endpoint fetches only the most recently generated forecast for all provided locations.  It uses the "dataStartAt" and 
"dataEndAt" parameters to scope the forecasted data points (if available for those times). If no start or end time 
boundaries are provided, the entire forecast dataset is used. The scoped data points are used to calculate average marginal 
carbon intensities of the specified "windowSize" and the optimal marginal carbon intensity window is identified.
            
The forecast data represents what the data source predicts future marginal carbon intesity values to be, 
not actual measured emissions data (as future values cannot be known).
            
This endpoint is useful for determining if there is a more carbon-optimal time to use electicity predicted in the future.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetCurrentForecastDataRequest
 */
func (a *CarbonAwareApiService) GetCurrentForecastData(ctx _context.Context) ApiGetCurrentForecastDataRequest {
	return ApiGetCurrentForecastDataRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []EmissionsForecastDTO
 */
func (a *CarbonAwareApiService) GetCurrentForecastDataExecute(r ApiGetCurrentForecastDataRequest) ([]EmissionsForecastDTO, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  []EmissionsForecastDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CarbonAwareApiService.GetCurrentForecastData")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/emissions/forecasts/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.location == nil {
		executionError.error = "location is required and must be specified"
		return localVarReturnValue, nil, executionError
	}

	{
		t := *r.location
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("location", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("location", parameterToString(t, "multi"))
		}
	}
	if r.dataStartAt != nil {
		localVarQueryParams.Add("dataStartAt", parameterToString(*r.dataStartAt, ""))
	}
	if r.dataEndAt != nil {
		localVarQueryParams.Add("dataEndAt", parameterToString(*r.dataEndAt, ""))
	}
	if r.windowSize != nil {
		localVarQueryParams.Add("windowSize", parameterToString(*r.windowSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ValidationProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 501 {
			var v ValidationProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiGetEmissionsDataForLocationByTimeRequest struct {
	ctx _context.Context
	ApiService *CarbonAwareApiService
	location *string
	time *time.Time
	toTime *time.Time
	durationMinutes *int32
}

func (r ApiGetEmissionsDataForLocationByTimeRequest) Location(location string) ApiGetEmissionsDataForLocationByTimeRequest {
	r.location = &location
	return r
}
func (r ApiGetEmissionsDataForLocationByTimeRequest) Time(time time.Time) ApiGetEmissionsDataForLocationByTimeRequest {
	r.time = &time
	return r
}
func (r ApiGetEmissionsDataForLocationByTimeRequest) ToTime(toTime time.Time) ApiGetEmissionsDataForLocationByTimeRequest {
	r.toTime = &toTime
	return r
}
func (r ApiGetEmissionsDataForLocationByTimeRequest) DurationMinutes(durationMinutes int32) ApiGetEmissionsDataForLocationByTimeRequest {
	r.durationMinutes = &durationMinutes
	return r
}

func (r ApiGetEmissionsDataForLocationByTimeRequest) Execute() ([]EmissionsData, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.GetEmissionsDataForLocationByTimeExecute(r)
}

/*
 * GetEmissionsDataForLocationByTime Calculate the best emission data by location for a specified time period.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetEmissionsDataForLocationByTimeRequest
 */
func (a *CarbonAwareApiService) GetEmissionsDataForLocationByTime(ctx _context.Context) ApiGetEmissionsDataForLocationByTimeRequest {
	return ApiGetEmissionsDataForLocationByTimeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []EmissionsData
 */
func (a *CarbonAwareApiService) GetEmissionsDataForLocationByTimeExecute(r ApiGetEmissionsDataForLocationByTimeRequest) ([]EmissionsData, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  []EmissionsData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CarbonAwareApiService.GetEmissionsDataForLocationByTime")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/emissions/bylocation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.location == nil {
		executionError.error = "location is required and must be specified"
		return localVarReturnValue, nil, executionError
	}

	localVarQueryParams.Add("location", parameterToString(*r.location, ""))
	if r.time != nil {
		localVarQueryParams.Add("time", parameterToString(*r.time, ""))
	}
	if r.toTime != nil {
		localVarQueryParams.Add("toTime", parameterToString(*r.toTime, ""))
	}
	if r.durationMinutes != nil {
		localVarQueryParams.Add("durationMinutes", parameterToString(*r.durationMinutes, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiGetEmissionsDataForLocationsByTimeRequest struct {
	ctx _context.Context
	ApiService *CarbonAwareApiService
	location *[]string
	time *time.Time
	toTime *time.Time
	durationMinutes *int32
}

func (r ApiGetEmissionsDataForLocationsByTimeRequest) Location(location []string) ApiGetEmissionsDataForLocationsByTimeRequest {
	r.location = &location
	return r
}
func (r ApiGetEmissionsDataForLocationsByTimeRequest) Time(time time.Time) ApiGetEmissionsDataForLocationsByTimeRequest {
	r.time = &time
	return r
}
func (r ApiGetEmissionsDataForLocationsByTimeRequest) ToTime(toTime time.Time) ApiGetEmissionsDataForLocationsByTimeRequest {
	r.toTime = &toTime
	return r
}
func (r ApiGetEmissionsDataForLocationsByTimeRequest) DurationMinutes(durationMinutes int32) ApiGetEmissionsDataForLocationsByTimeRequest {
	r.durationMinutes = &durationMinutes
	return r
}

func (r ApiGetEmissionsDataForLocationsByTimeRequest) Execute() ([]EmissionsData, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.GetEmissionsDataForLocationsByTimeExecute(r)
}

/*
 * GetEmissionsDataForLocationsByTime Calculate the observed emission data by list of locations for a specified time period.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetEmissionsDataForLocationsByTimeRequest
 */
func (a *CarbonAwareApiService) GetEmissionsDataForLocationsByTime(ctx _context.Context) ApiGetEmissionsDataForLocationsByTimeRequest {
	return ApiGetEmissionsDataForLocationsByTimeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []EmissionsData
 */
func (a *CarbonAwareApiService) GetEmissionsDataForLocationsByTimeExecute(r ApiGetEmissionsDataForLocationsByTimeRequest) ([]EmissionsData, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  []EmissionsData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CarbonAwareApiService.GetEmissionsDataForLocationsByTime")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/emissions/bylocations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.location == nil {
		executionError.error = "location is required and must be specified"
		return localVarReturnValue, nil, executionError
	}

	{
		t := *r.location
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("location", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("location", parameterToString(t, "multi"))
		}
	}
	if r.time != nil {
		localVarQueryParams.Add("time", parameterToString(*r.time, ""))
	}
	if r.toTime != nil {
		localVarQueryParams.Add("toTime", parameterToString(*r.toTime, ""))
	}
	if r.durationMinutes != nil {
		localVarQueryParams.Add("durationMinutes", parameterToString(*r.durationMinutes, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}
